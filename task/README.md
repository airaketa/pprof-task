# Оптимизация golang скрипта

***Данное задание взято из курса Разработка веб-сервисов на Go от Mail.Ru Group под авторством Романова Василия Вячеславовича.***

## Введение

Задание на работу с профайлером `pprof`.

Есть функция Search, которая парсит файл и выводит нужные данные. 
Но делает она это не очень быстро. Надо её оптимизировать.

## Цель

Научиться работать с pprof, находить горячие места в коде, уметь строить профиль 
потребления cpu и памяти, оптимизировать код с учетом этой информации.

## Задача

**С использованием pprof** оптимизировать функцию Search.
Для выполнения задания необходимо чтобы каждый из параметров ( ns/op, B/op, allocs/op ) был быстрее чем:
```
BenchmarkFast-12 500 2782432 ns/op 559910 B/op 10422 allocs/op
```

По памяти ( B/op ) и количеству аллокаций ( allocs/op ) можно ориентироваться ровно на 
результаты выше, по времени ( ns/op ) - нет, зависит от системы.

## Структура директорий

```shell
├── data
│   └── users.txt - Файл с данными, которые будет парсить функция Search
├── fast
│   └── search.go - Оптимизированная вами реализация этой функции. По сути только здесь вам 
                    и нужно вносить изменения. По умолчанию здесь такой же код как и в slow/search.go
├── slow
│   └── search.go - Здесь базовая и медленная реализация функционала. Опираемся на нее. 
                    !!!Здесь не нужно ничего менять
├── main.go - Балванка, которая запускает fast/search.go
├── main_test.go - Здесь написаны тесты для проверки функциональных требований 
                   а также бенчмарки для проверки производительности
└── Makefile - Makefile для упрощения вызова команд
```

## Запуск

### Бенчмарк
При выполнении этой команды запустится тест, который проверит что функционал не сломан. После
этого запустится бенчмарк
```shell
make   # он же go test -bench .  -benchmem
```

### Профилирование
При запуске следующих команд автомачиски будет запускаться бенчмарк fast/search.go 
который соберет необходимые профили. За подробнастями смотрите makefile
```shell
make cpu-pprof # он же go tool pprof pprof-task.test pprof-profiles/cpu.out
```
```shell
make mem-pprof # он же go go tool pprof pprof-task.test pprof-profiles/mem.out
```

### Команды внутри pprof
Постройка графа потребления ресурса:
```shell
web 
```
Посмотреть потребление ресурса в текстовом виде для конкретной функции (поддерживается regex)
```shell
list Search
```

По умолчанию после выполнения make mem-pprof вы будете в режиме просмотра аллоцируемого пространства.
Для перехода в режим просмотра количества аллокаций, выполните/
```
alloc_objects
```
После выполнения все команды будут показывать информацию по кол-ву аллокаций, а не по пространству.

## Post Scriptum
* В коде есть много мест, которые можно оптимизировать и их видно невооруженным глазом. Однако цель
этого задания - научиться/попрактиковаться в использовании pprof, поэтому необходимо пользоваться им
для определения проблемных мест. Ну и плюс если вы хотите достигнуть максимальной оптимизации, то без 
pprof уже никак.
* Задание предполагает использование easyjson. Это библиотека для кодогенерации json парсеров. 
Но тут на вкус и цвет. Есть другие библиотеки со схожим функционалом. Берите что нравится,
главное чтобы работало быстро.
* В какой-то момент для дальнейшей оптимизации нужно будет сделать код трудно читаемым и абсолютно
не годный для какого-нибудь прод решения. Это нормально, здесь мы оптимизируем ради оптимизации и отрываемся от души :)

## Материалы для чтения по теме
[Профилирование и оптимизация программ на Go](https://habr.com/ru/company/badoo/blog/301990/)

[Профилирование и оптимизация веб-приложений на Go](https://habr.com/ru/company/badoo/blog/324682/)

[Инструменты для разработчика Go: знакомимся с лейблами профайлера](https://habr.com/ru/company/badoo/blog/332636/)

[Миллион WebSocket и Go](https://habr.com/ru/company/vk/blog/331784/)

[Генерация кода в Go](https://habr.com/ru/post/269887/)